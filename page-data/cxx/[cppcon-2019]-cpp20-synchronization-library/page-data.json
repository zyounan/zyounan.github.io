{"componentChunkName":"component---src-templates-blog-post-js","path":"/cxx/[cppcon-2019]-cpp20-synchronization-library/","result":{"data":{"site":{"siteMetadata":{"title":"zyounan's blog","author":"zyounan","siteUrl":"https://zyounan.github.io","comment":{"disqusShortName":"","utterances":""},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"3eb08d64-f046-5af6-b547-d560a76f8824","excerpt":"视频地址\nSlides","html":"<p><a href=\"https://www.youtube.com/watch?v=Zcqwb3CWqs4\">视频地址</a>\n<a href=\"https://github.com/CppCon/CppCon2019/blob/master/Presentations/cpp20_synchronization_library/cpp20_synchronization_library__r2__bryce_adelstein_lelbach__cppcon_2019.pdf\">Slides</a>  </p>\n<!-- separate -->\n<p>大致介绍了新增的四种同步设施  </p>\n<ul>\n<li><code class=\"language-text\">std::atomic::wait</code> 和 <code class=\"language-text\">std::atomic::notify_*</code> </li>\n<li><code class=\"language-text\">std::atomic_ref</code> 对非 <code class=\"language-text\">atomic</code> 对象的方便地应用 <code class=\"language-text\">std::atomic</code> 操作</li>\n<li><code class=\"language-text\">std::counting_semaphore</code></li>\n<li><code class=\"language-text\">std::latch</code> 和 <code class=\"language-text\">std::barrier</code> 线程同步设施</li>\n</ul>\n<h3 id=\"code-classlanguage-textjthreadcode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textjthreadcode\" aria-label=\"code classlanguage textjthreadcode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">jthread</code></h3>\n<ol>\n<li><code class=\"language-text\">j</code> 代表 <code class=\"language-text\">joinable</code>（也是提案 P0660 的作者之一的名字首字母）</li>\n<li>析构的时候如果 <code class=\"language-text\">joinable</code>，会 <code class=\"language-text\">join()</code> 而不是 <code class=\"language-text\">terminate</code></li>\n<li>\n<p><code class=\"language-text\">invocable</code> 可以接受 <code class=\"language-text\">std::stop_token</code> 作为第一个参数</p>\n<ul>\n<li><code class=\"language-text\">std::stop_source</code> 类似于 <code class=\"language-text\">promise</code></li>\n<li>\n<p><code class=\"language-text\">std::stop_token</code> 类似于 <code class=\"language-text\">future</code></p>\n<ul>\n<li>A stop<em>token object is not generally constructed independently, but rather retrieved from a std::jthread or std::stop</em>source. This makes it share the same associated stop-state as the std::jthread or std::stop_source.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">std::stop_callback</code> 类似于 <code class=\"language-text\">future::then</code></p>\n<ul>\n<li>要绑定到 <code class=\"language-text\">stop_token</code> 上</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"自旋锁\" style=\"position:relative;\"><a href=\"#%E8%87%AA%E6%97%8B%E9%94%81\" aria-label=\"自旋锁 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>自旋锁</h3>\n<ol>\n<li>使用 <code class=\"language-text\">std::atomic_flag</code> 实现</li>\n</ol>\n<p>Naive 的版本：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">spin_mutex</span> <span class=\"token punctuation\">{</span>\n    std<span class=\"token operator\">::</span>atomic_flag flag <span class=\"token operator\">=</span> ATOMIC_FLAG_INIT<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">.</span><span class=\"token function\">test_and_set</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>memory_order<span class=\"token operator\">::</span>acquire<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        flag<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>memory_order<span class=\"token operator\">::</span>release<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>浪费效率。考虑改进：记录自旋次数，然后根据不同的次数做不同的操作。</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>unit64_t i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> flag<span class=\"token punctuation\">.</span><span class=\"token function\">test_and_set</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>memory_order<span class=\"token operator\">::</span>acquire<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// do_nop</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> <span class=\"token number\">64</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// yield</span>\n        <span class=\"token keyword\">else</span> <span class=\"token comment\">//do_sleep</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>C++20: 在 <code class=\"language-text\">atomic</code> 上的等待操作</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">.</span><span class=\"token function\">test_and_set</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>memory_order<span class=\"token operator\">::</span>acquire<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        flag<span class=\"token punctuation\">.</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>memory_order_relaxed<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    flag<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>memory_order<span class=\"token operator\">::</span>release<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    flag<span class=\"token punctuation\">.</span><span class=\"token function\">notify_one</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">wait</code> 和 <code class=\"language-text\">notify</code> 都有啥实现策略呢？</p>\n<ul>\n<li>\n<p>Futex: Fast Userspace Mutex</p>\n<ul>\n<li>这玩意儿在 Windows 下有类似的实现是 <code class=\"language-text\">WaitOnAddress</code></li>\n<li><a href=\"https://devblogs.microsoft.com/oldnewthing/20170601-00/?p=96265\">Futex vs WaitOnAddress</a></li>\n</ul>\n</li>\n<li>Condition Variables</li>\n<li>Spin Lock</li>\n</ul>\n<p>原来的 Slides 上还放了几个方法，但是没找到相关的资料</p>\n<ul>\n<li>Contention Table</li>\n<li>Timed back-off</li>\n</ul>\n<h4 id=\"ticket-lock\" style=\"position:relative;\"><a href=\"#ticket-lock\" aria-label=\"ticket lock permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Ticket lock</h4>\n<p>自旋锁的一种</p>\n<p>两个 <code class=\"language-text\">atomic</code>，类似于排队叫号的设计</p>\n<p>防止一个线程进入 <code class=\"language-text\">lock</code> 的时候被另一个线程抢先（插队）</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">ticket_mutex</span> <span class=\"token punctuation\">{</span>\n    std<span class=\"token operator\">::</span>atomic<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> in <span class=\"token operator\">=</span> <span class=\"token function\">ATOMIC_VAR_INIT</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    std<span class=\"token operator\">::</span>atomic<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> out <span class=\"token operator\">=</span> <span class=\"token function\">ATOMIC_VAR_INIT</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">auto</span> <span class=\"token keyword\">const</span> my <span class=\"token operator\">=</span> in<span class=\"token punctuation\">.</span><span class=\"token function\">fetch_add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>memory_order<span class=\"token operator\">::</span>acquire<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">auto</span> <span class=\"token keyword\">const</span> now <span class=\"token operator\">=</span> out<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>memory_order<span class=\"token operator\">::</span>acquire<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>my <span class=\"token operator\">==</span> now<span class=\"token punctuation\">)</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            out<span class=\"token punctuation\">.</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>now<span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>memory_order<span class=\"token operator\">::</span>relaxed<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        out<span class=\"token punctuation\">.</span><span class=\"token function\">fetch_add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> std<span class=\"token operator\">::</span>memory_order<span class=\"token operator\">::</span>release<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        out<span class=\"token punctuation\">.</span><span class=\"token function\">notify_all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>False Sharing</strong></p>\n<p><code class=\"language-text\">in</code> 和 <code class=\"language-text\">out</code> 可能会被放到一个 <code class=\"language-text\">Cache Line</code> 中。两个相互独立的原子变量都会导致 Cache 的重新装载</p>\n<p>解决方案：</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">alignas</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>hardware_destructive_interference_size<span class=\"token punctuation\">)</span>\nstd<span class=\"token operator\">::</span>atomic<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> in <span class=\"token operator\">=</span> <span class=\"token function\">ATOMIC_VAR_INIT</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">std::hardware_constructive_interference_size</code> 是保证 <code class=\"language-text\">True sharing</code> 的最大上限，\n<code class=\"language-text\">std::hardware_destructive_interference_size</code> 是保证 <code class=\"language-text\">False sharing</code> 的最小下限。</p>\n<h3 id=\"code-classlanguage-textstdlatchcode-vs-code-classlanguage-textstdbarriercode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textstdlatchcode-vs-code-classlanguage-textstdbarriercode\" aria-label=\"code classlanguage textstdlatchcode vs code classlanguage textstdbarriercode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">std::latch</code> vs <code class=\"language-text\">std::barrier</code></h3>\n<p><code class=\"language-text\">latch</code> 有门闩的意思，实际上很形象：大致作用就是让所有线程们遇到它就阻塞，同时等待某个事件</p>\n<ul>\n<li>Supports asynchronous arrival</li>\n</ul>\n<p>考虑这样的一个场景，假设有一个任务队列</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">template</span> <span class=\"token operator\">&lt;</span>size_t QueueDepth<span class=\"token operator\">></span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">bounded_depth_task_manager</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">process_tasks</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>stop_token s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">stop_requested</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            tasks<span class=\"token punctuation\">.</span><span class=\"token function\">deque</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">operator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 如果最后一个任务在线程 A deque 之前被线程 B 取走了</span>\n        <span class=\"token comment\">// 那么线程 A 就阻塞到 tasks 中等待，但是这个时候队列是空的</span>\n        <span class=\"token comment\">// 我们需要把它从这个循环中拿出来</span>\n\n        <span class=\"token comment\">// 确保队列在 `request_stop` 后是空的</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">auto</span> task <span class=\"token operator\">=</span> tasks<span class=\"token punctuation\">.</span><span class=\"token function\">try_deque</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  std<span class=\"token operator\">::</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>task<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">~</span><span class=\"token function\">bounded_depth_task_manager</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        std<span class=\"token operator\">::</span>latch <span class=\"token function\">l</span><span class=\"token punctuation\">(</span>threads<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 线程数 + 主线程</span>\n        <span class=\"token comment\">// 确保每个线程取到一次这个任务，然后在上面等待</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">:</span> std<span class=\"token operator\">::</span>views<span class=\"token operator\">::</span><span class=\"token function\">iota</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> threads<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            tasks<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span> l<span class=\"token punctuation\">.</span><span class=\"token function\">arrive_and_wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n        threads<span class=\"token punctuation\">.</span><span class=\"token function\">request_stop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        l<span class=\"token punctuation\">.</span><span class=\"token function\">count_down</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>         <span class=\"token comment\">// 如果所有线程都阻塞在这个任务上了，那么现在的计数值就是 1</span>\n        <span class=\"token comment\">// 主线程释放掉这个，那么所有的线程就可以继续运行，之后正常退出</span>\n        <span class=\"token comment\">// 相当于让所有线程都在等待一件事情</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">std::latch</code> 是一次性的，也就是它的计数值是不能增加的。\n<code class=\"language-text\">std::barrier</code> 就不是一次性的。它拥有多个阶段 (phases)，每个阶段在线程计数值到 0 后调用回调；之后重新将计数值调整到构造函数指定的值。</p>","frontmatter":{"title":"「cppcon 2019」cpp20-synchronization-library","date":"March 25, 2021"}}},"pageContext":{"slug":"/cxx/[cppcon-2019]-cpp20-synchronization-library/","previous":{"fields":{"slug":"/随手记/bazel-学习笔记/"},"frontmatter":{"title":"Bazel 学习笔记","category":"随手记","draft":false}},"next":null}},"staticQueryHashes":["3128451518","52803243"]}