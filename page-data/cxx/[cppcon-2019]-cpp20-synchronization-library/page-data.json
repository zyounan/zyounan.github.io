{"componentChunkName":"component---src-templates-blog-post-js","path":"/cxx/[cppcon-2019]-cpp20-synchronization-library/","result":{"data":{"site":{"siteMetadata":{"title":"zyounan's blog","author":"zyounan","siteUrl":"https://zyounan.github.io","comment":{"disqusShortName":"","utterances":""},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"3eb08d64-f046-5af6-b547-d560a76f8824","excerpt":"视频地址\nSlides","html":"<p><a href=\"https://www.youtube.com/watch?v=Zcqwb3CWqs4\">视频地址</a>\n<a href=\"https://github.com/CppCon/CppCon2019/blob/master/Presentations/cpp20_synchronization_library/cpp20_synchronization_library__r2__bryce_adelstein_lelbach__cppcon_2019.pdf\">Slides</a>  </p>\n<!-- separate -->\n<p>大致介绍了新增的四种同步设施  </p>\n<ul>\n<li><code class=\"language-text\">std::atomic::wait</code> 和 <code class=\"language-text\">std::atomic::notify_*</code> </li>\n<li><code class=\"language-text\">std::atomic_ref</code> 对非 <code class=\"language-text\">atomic</code> 对象的方便地应用 <code class=\"language-text\">std::atomic</code> 操作</li>\n<li><code class=\"language-text\">std::counting_semaphore</code></li>\n<li><code class=\"language-text\">std::latch</code> 和 <code class=\"language-text\">std::barrier</code> 线程同步设施</li>\n</ul>\n<h3 id=\"code-classlanguage-textjthreadcode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textjthreadcode\" aria-label=\"code classlanguage textjthreadcode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">jthread</code></h3>\n<ol>\n<li><code class=\"language-text\">j</code> 代表 <code class=\"language-text\">joinable</code>（也是提案 P0660 的作者之一的名字首字母）</li>\n<li>析构的时候如果 <code class=\"language-text\">joinable</code>，会 <code class=\"language-text\">join()</code> 而不是 <code class=\"language-text\">terminate</code></li>\n<li>\n<p><code class=\"language-text\">invocable</code> 可以接受 <code class=\"language-text\">std::stop_token</code> 作为第一个参数</p>\n<ul>\n<li><code class=\"language-text\">std::stop_source</code> 类似于 <code class=\"language-text\">promise</code></li>\n<li>\n<p><code class=\"language-text\">std::stop_token</code> 类似于 <code class=\"language-text\">future</code></p>\n<ul>\n<li>A stop<em>token object is not generally constructed independently, but rather retrieved from a std::jthread or std::stop</em>source. This makes it share the same associated stop-state as the std::jthread or std::stop_source.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">std::stop_callback</code> 类似于 <code class=\"language-text\">future::then</code></p>\n<ul>\n<li>要绑定到 <code class=\"language-text\">stop_token</code> 上</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"自旋锁\" style=\"position:relative;\"><a href=\"#%E8%87%AA%E6%97%8B%E9%94%81\" aria-label=\"自旋锁 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>自旋锁</h3>\n<ol>\n<li>使用 <code class=\"language-text\">std::atomic_flag</code> 实现</li>\n</ol>\n<p>Naive 的版本：</p>\n<div class=\"gatsby-highlight\" data-language=\"cxx\"><pre class=\"language-cxx\"><code class=\"language-cxx\">struct spin_mutex {\n    std::atomic_flag flag = ATOMIC_FLAG_INIT;\n\n    void lock() {\n        while (flag.test_and_set(std::memory_order::acquire))\n            ;\n    }\n\n    void unlock() {\n        flag.clear(std::memory_order::release);\n    }\n};</code></pre></div>\n<p>浪费效率。考虑改进：记录自旋次数，然后根据不同的次数做不同的操作。</p>\n<div class=\"gatsby-highlight\" data-language=\"cxx\"><pre class=\"language-cxx\"><code class=\"language-cxx\">void lock() {\n    for (unit64_t i = 0; flag.test_and_set(std::memory_order::acquire); ++i) {\n        if (i &lt; 4) ;\n        else if (i &lt; 16) // do_nop\n        else if (i &lt; 64) // yield\n        else //do_sleep\n    }\n}</code></pre></div>\n<p>C++20: 在 <code class=\"language-text\">atomic</code> 上的等待操作</p>\n<div class=\"gatsby-highlight\" data-language=\"cxx\"><pre class=\"language-cxx\"><code class=\"language-cxx\">void lock() {\n    while (flag.test_and_set(std::memory_order::acquire))\n        flag.wait(true, std::memory_order_relaxed);\n}\n\nvoid unlock() {\n    flag.clear(std::memory_order::release);\n    flag.notify_one();\n}</code></pre></div>\n<p><code class=\"language-text\">wait</code> 和 <code class=\"language-text\">notify</code> 都有啥实现策略呢？</p>\n<ul>\n<li>\n<p>Futex: Fast Userspace Mutex</p>\n<ul>\n<li>这玩意儿在 Windows 下有类似的实现是 <code class=\"language-text\">WaitOnAddress</code></li>\n<li><a href=\"https://devblogs.microsoft.com/oldnewthing/20170601-00/?p=96265\">Futex vs WaitOnAddress</a></li>\n</ul>\n</li>\n<li>Condition Variables</li>\n<li>Spin Lock</li>\n</ul>\n<p>原来的 Slides 上还放了几个方法，但是没找到相关的资料</p>\n<ul>\n<li>Contention Table</li>\n<li>Timed back-off</li>\n</ul>\n<h4 id=\"ticket-lock\" style=\"position:relative;\"><a href=\"#ticket-lock\" aria-label=\"ticket lock permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Ticket lock</h4>\n<p>自旋锁的一种</p>\n<p>两个 <code class=\"language-text\">atomic</code>，类似于排队叫号的设计</p>\n<p>防止一个线程进入 <code class=\"language-text\">lock</code> 的时候被另一个线程抢先（插队）</p>\n<div class=\"gatsby-highlight\" data-language=\"cxx\"><pre class=\"language-cxx\"><code class=\"language-cxx\">struct ticket_mutex {\n    std::atomic&lt;int&gt; in = ATOMIC_VAR_INIT(0);\n    std::atomic&lt;int&gt; out = ATOMIC_VAR_INIT(0);\n\n    void lock() {\n        auto const my = in.fetch_add(1, std::memory_order::acquire);\n        while (true) {\n            auto const now = out.load(std::memory_order::acquire);\n            if (my == now) break;\n            out.wait(now, std::memory_order::relaxed);\n        }\n    }\n\n    void unlock() {\n        out.fetch_add(1, std::memory_order::release);\n        out.notify_all();\n    }\n};</code></pre></div>\n<p><strong>False Sharing</strong></p>\n<p><code class=\"language-text\">in</code> 和 <code class=\"language-text\">out</code> 可能会被放到一个 <code class=\"language-text\">Cache Line</code> 中。两个相互独立的原子变量都会导致 Cache 的重新装载</p>\n<p>解决方案：</p>\n<div class=\"gatsby-highlight\" data-language=\"cxx\"><pre class=\"language-cxx\"><code class=\"language-cxx\">alignas(std::hardware_destructive_interference_size)\nstd::atomic&lt;int&gt; in = ATOMIC_VAR_INIT(0);</code></pre></div>\n<p><code class=\"language-text\">std::hardware_constructive_interference_size</code> 是保证 <code class=\"language-text\">True sharing</code> 的最大上限，\n<code class=\"language-text\">std::hardware_destructive_interference_size</code> 是保证 <code class=\"language-text\">False sharing</code> 的最小下限。</p>\n<h3 id=\"code-classlanguage-textstdlatchcode-vs-code-classlanguage-textstdbarriercode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textstdlatchcode-vs-code-classlanguage-textstdbarriercode\" aria-label=\"code classlanguage textstdlatchcode vs code classlanguage textstdbarriercode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">std::latch</code> vs <code class=\"language-text\">std::barrier</code></h3>\n<p><code class=\"language-text\">latch</code> 有门闩的意思，实际上很形象：大致作用就是让所有线程们遇到它就阻塞，同时等待某个事件</p>\n<ul>\n<li>Supports asynchronous arrival</li>\n</ul>\n<p>考虑这样的一个场景，假设有一个任务队列</p>\n<div class=\"gatsby-highlight\" data-language=\"cxx\"><pre class=\"language-cxx\"><code class=\"language-cxx\">template &lt;size_t QueueDepth&gt;\nstruct bounded_depth_task_manager {\n\n    void process_tasks(std::stop_token s) {\n        while (!s.stop_requested())\n            tasks.deque().operator()();\n        // 如果最后一个任务在线程 A deque 之前被线程 B 取走了\n        // 那么线程 A 就阻塞到 tasks 中等待，但是这个时候队列是空的\n        // 我们需要把它从这个循环中拿出来\n\n        // 确保队列在 `request_stop` 后是空的\n        while (true) {\n            if (auto task = tasks.try_deque())  std::move(*task)();\n            else break;\n        }\n    }\n    ~bounded_depth_task_manager() {\n        std::latch l(threads.size() + 1); // 线程数 + 主线程\n        // 确保每个线程取到一次这个任务，然后在上面等待\n        for (int i : std::views::iota(0, threads.size()))\n            tasks.submit([&amp;] { l.arrive_and_wait(); }); \n        threads.request_stop();\n        l.count_down();         // 如果所有线程都阻塞在这个任务上了，那么现在的计数值就是 1\n        // 主线程释放掉这个，那么所有的线程就可以继续运行，之后正常退出\n        // 相当于让所有线程都在等待一件事情\n    }\n};</code></pre></div>\n<p><code class=\"language-text\">std::latch</code> 是一次性的，也就是它的计数值是不能增加的。\n<code class=\"language-text\">std::barrier</code> 就不是一次性的。它拥有多个阶段 (phases)，每个阶段在线程计数值到 0 后调用回调；之后重新将计数值调整到构造函数指定的值。</p>","frontmatter":{"title":"「cppcon 2019」cpp20-synchronization-library","date":"March 25, 2021"}}},"pageContext":{"slug":"/cxx/[cppcon-2019]-cpp20-synchronization-library/","previous":{"fields":{"slug":"/随手记/bazel-学习笔记/"},"frontmatter":{"title":"Bazel 学习笔记","category":"随手记","draft":false}},"next":null}},"staticQueryHashes":["3128451518","52803243"]}