{"componentChunkName":"component---src-templates-blog-post-js","path":"/cxx/[cppcon-2018]-rvo-harder-than-it-looks/","result":{"data":{"site":{"siteMetadata":{"title":"zyounan's blog","author":"zyounan","siteUrl":"https://zyounan.github.io","comment":{"disqusShortName":"","utterances":""},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"b107a2bf-638e-53f4-ba41-21baebcb873a","excerpt":"视频地址\nSlides","html":"<p><a href=\"https://www.youtube.com/watch?v=hA1WNtNyNbo&#x26;ab_channel=CppCon\">视频地址</a>\n<a href=\"https://github.com/CppCon/CppCon2018/blob/master/Presentations/return_value_optimization_harder_than_it_looks/return_value_optimization_harder_than_it_looks__arthur_odwyer__cppcon_2018.pdf\">Slides</a></p>\n<!-- separate -->\n<ol>\n<li>Return slot</li>\n</ol>\n<p><code class=\"language-text\">x86-64</code> 的调用约定中，对于某些返回值不能塞入寄存器（往往是 <code class=\"language-text\">rax</code>）中的情形，编译器会额外地添加一个隐式参数（<code class=\"language-text\">return slot address</code>），用于传递一个指向返回值的地址（往往是 <code class=\"language-text\">rdi</code>）。</p>\n<p>调用方拥有 <code class=\"language-text\">return slot</code></p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">S</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">S</span><span class=\"token punctuation\">(</span>S<span class=\"token operator\">&amp;&amp;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">auto</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">bool</span> cond<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    S x <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    S y <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token keyword\">return</span> std<span class=\"token operator\">::</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>cond <span class=\"token operator\">?</span> x <span class=\"token operator\">:</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>注意到这里由于没有办法立刻知道返回的结果，所以不能直接把对象构造到 <code class=\"language-text\">return slot</code> 中。</p>\n<ol start=\"2\">\n<li>复制消除</li>\n</ol>\n<p>C++17 强制要求</p>\n<p>什么时候不能？</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">auto</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> S y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> y<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>不知道 <code class=\"language-text\">y</code> 的实际位置，所以没办法直接把 <code class=\"language-text\">y</code> 给 <code class=\"language-text\">return slot</code>。以此类推，</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">static</span> S x<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">auto</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>也无法进行复制消除。（我们不知道 <code class=\"language-text\">x</code> 实际存放在哪里）</p>\n<p>继承……？\n如果子类比父类的 <code class=\"language-text\">size</code> 大</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">SS</span> <span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token class-name\">S</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">double</span> member<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nS <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    SS something <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> something<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>同样也不会进行 RVO</p>\n<ol start=\"3\">\n<li>隐式移动 (Implicitly move)</li>\n</ol>\n<p><a href=\"https://wg21.cmeerw.net/cwg/issue1579\">CWG 1579</a>，做了一些修正.</p>\n<p>优先把对象当成“右值”，根据重载决议选择移动构造函数。如果重载决议失败了，或者说重载决议选择的构造函数的第一个参数<strong>不是一个指向该对象的右值引用（可以有 cv 限定）</strong>，那么就再把它当成“左值”再去进行一次重载决议。</p>\n<p>目前的<a href=\"http://eel.is/c++draft/class.copy.elision#3\">([class.copy.elison]/3)</a>是，如果 <code class=\"language-text\">return</code> 语句中的表达式是 <code class=\"language-text\">id-expression</code>，并且这个表达式指代的对象在函数体或者参数中，并且可以被移动，那么就优先考虑移动操作。</p>\n<p>所以如果是继承的对象的话，即使有移动构造函数，但是如果不是完全匹配的话，那么仍然不会进行隐式移动。</p>\n<p>这个提案被加进去的原因之一是因为 <code class=\"language-text\">std::unique_ptr</code>，</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token operator\">::</span>unique_ptr<span class=\"token operator\">&lt;</span>ConfigManager<span class=\"token operator\">></span> <span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">auto</span> p <span class=\"token operator\">=</span> std<span class=\"token operator\">::</span>make_unique<span class=\"token operator\">&lt;</span>ConfigManagerImpl<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> p<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里面就不需要 <code class=\"language-text\">conversion operators</code>，只需要有一个接受右值引用的构造函数(<code class=\"language-text\">converting constructors</code>)就行了。</p>\n<p>还是他的一篇博文：\n<a href=\"https://quuxplusone.github.io/blog/2021/03/07/copy-elision-borks-escape-analysis/\">https://quuxplusone.github.io/blog/2021/03/07/copy-elision-borks-escape-analysis/</a></p>","frontmatter":{"title":"「cppcon-2018」 RVO-harder-than-it-looks","date":"April 13, 2021"}}},"pageContext":{"slug":"/cxx/[cppcon-2018]-rvo-harder-than-it-looks/","previous":{"fields":{"slug":"/cxx/[cppcon-2019]-cpp20-synchronization-library/"},"frontmatter":{"title":"「cppcon 2019」cpp20-synchronization-library","category":"cxx","draft":false}},"next":{"fields":{"slug":"/cxx/[cppcon-2019]-a-unifying-abstraction-for-async-in-c++/"},"frontmatter":{"title":"「cppcon-2019」A Unifying Abstraction for Async in C++","category":"cxx","draft":false}}}},"staticQueryHashes":["3128451518","52803243"]}