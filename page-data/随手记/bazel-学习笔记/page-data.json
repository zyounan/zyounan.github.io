{"componentChunkName":"component---src-templates-blog-post-js","path":"/随手记/bazel-学习笔记/","result":{"data":{"site":{"siteMetadata":{"title":"zyounan's blog","author":"zyounan","siteUrl":"https://zyounan.github.io","comment":{"disqusShortName":"","utterances":""},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"63064328-de4a-593e-b92d-31d881fa7a6e","excerpt":"官方文档的大致整理 :)","html":"<p>官方文档的大致整理 :)</p>\n<!-- separate -->\n<h3 id=\"一些基本概念和名词\" style=\"position:relative;\"><a href=\"#%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%90%8D%E8%AF%8D\" aria-label=\"一些基本概念和名词 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>一些基本概念和名词</h3>\n<h4 id=\"workspace\" style=\"position:relative;\"><a href=\"#workspace\" aria-label=\"workspace permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Workspace</h4>\n<p>拥有一个名为 <code class=\"language-text\">WORKSPACE</code> 文件的目录被称为 <code class=\"language-text\">workspace</code> 的根目录。根目录下的子目录如果拥有 <code class=\"language-text\">WORKSPACE</code> 则会被忽略。<code class=\"language-text\">WORKSPACE.bazel</code> 是别名，只不过优先级更高一些。</p>\n<h4 id=\"repositories\" style=\"position:relative;\"><a href=\"#repositories\" aria-label=\"repositories permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Repositories</h4>\n<p>包含 <code class=\"language-text\">WORKSPACE</code> 文件的目录是主仓库的根目录，也被缩写为 <code class=\"language-text\">@</code>。外部的仓库在 <code class=\"language-text\">WORKSPACE</code> 文件中定义。</p>\n<h4 id=\"packages\" style=\"position:relative;\"><a href=\"#packages\" aria-label=\"packages permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Packages</h4>\n<p>仓库中代码组织的基本单位是 <code class=\"language-text\">package</code>。包里面包含文件/外部依赖。\n包所在的目录应该包含一个名字是 <code class=\"language-text\">BUILD</code> 或者 <code class=\"language-text\">BUILD.bazel</code> 的文件。一个包包含了它的所有<strong>除含有 <code class=\"language-text\">BUILD(.bazel)</code> 的</strong>子目录。</p>\n<h4 id=\"targets\" style=\"position:relative;\"><a href=\"#targets\" aria-label=\"targets permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Targets</h4>\n<p>所谓的 <code class=\"language-text\">package</code> （以下写成<em>包</em>）就是一个容器。包中的元素被称为 <code class=\"language-text\">targets</code>。<code class=\"language-text\">targets</code> 由<strong>文件</strong> 和 <strong>规则</strong> 组成，另外也有 <code class=\"language-text\">package groups</code>。</p>\n<ul>\n<li>文件被分为两类。一种是代码文件，一种是构造工具（例如 <code class=\"language-text\">Qt Moc</code>）生成的文件</li>\n<li>规则。处理输入，生成输出。规则的输出永远被看成生成的文件。规则的输入可能是代码文件，也可能包含其它的规则文件。</li>\n</ul>\n<h4 id=\"labels\" style=\"position:relative;\"><a href=\"#labels\" aria-label=\"labels permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Labels</h4>\n<p><code class=\"language-text\">Target</code> 的名字被称为 <code class=\"language-text\">label</code>（标签）。形式地来讲，</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">@myrepo//my/app/main:app_binary</code></pre></div>\n<ol>\n<li>如果标签引用的 <code class=\"language-text\">target</code> 在同一个仓库下面，仓库名 <code class=\"language-text\">@myrepo</code> 可以省略。</li>\n<li>标签由两个部分组成。由 <code class=\"language-text\">//</code> 打头，包名 (<code class=\"language-text\">my/app/main</code>) 和目标名 (<code class=\"language-text\">app_binary</code>)。如果冒号被省略了，那么就认为目标名和包名的最后一个部分(例子中的 <code class=\"language-text\">main</code>) 一致。</li>\n<li>\n<p>在一个 <code class=\"language-text\">BUILD</code> 规则中，以下形式是等价的</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">//my/app:app\n//my/app\n:app\napp</code></pre></div>\n</li>\n<li><code class=\"language-text\">BUILD</code> 规则中可以使用相对（包目录的）路径指向文件。但是如果在别的地方，例如命令行中，有 <code class=\"language-text\">//my/app:generate.cc</code>。</li>\n</ol>\n<p>相对路径不能被用来指向其他包中的 <code class=\"language-text\">targets</code>。这个时候就必须用完整路径了。举一个例子，例如代码目录包含包<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> <code class=\"language-text\">my/app</code> 和包 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> <code class=\"language-text\">my/app/testdata</code> 。包 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 包含有 <code class=\"language-text\">testdepot.zip</code> 这个文件。那么\n<code class=\"language-text\">testdata/testdepot.zip</code> 这样的写法不行、但是 <code class=\"language-text\">//my/app/testdata:testdepot.zip</code> 这样的写法是可以的。</p>\n<p>以 <code class=\"language-text\">@//</code> 打头的标签指向的是主仓库(从外部仓库的视角来看也是这样的!) 因此 <code class=\"language-text\">@//a/b/c</code> 和 <code class=\"language-text\">//a/b/c</code> 是不一样的。</p>\n<h4 id=\"code-classlanguage-textlabelscode-的命名规则\" style=\"position:relative;\"><a href=\"#code-classlanguage-textlabelscode-%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99\" aria-label=\"code classlanguage textlabelscode 的命名规则 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">Labels</code> 的命名规则</h4>\n<ul>\n<li>目标名, <code class=\"language-text\">//...:target-name</code></li>\n<li>规则的名字就是 <code class=\"language-text\">BUILD</code> 文件中 <code class=\"language-text\">name</code> 的值</li>\n<li>文件的名字就是相对于包含 <code class=\"language-text\">BUILD</code> 文件的路径名</li>\n<li>允许使用的符号 <code class=\"language-!\">-@^_` &quot;#$&amp;&#39;()*-+,;&lt;=&gt;?[]{|}~/.</code> 以及 <code class=\"language-text\">[0-9A-Za-z]</code></li>\n<li>如果要指代其他的包，请不要使用 <code class=\"language-text\">..</code> 这样的符号。使用 <code class=\"language-text\">//packagename:filename</code>。路径名必须是相对的，但是 <code class=\"language-text\">..</code> 和 <code class=\"language-text\">./</code> 和用 <code class=\"language-text\">/</code> 作为路径的开头和结尾这样的作法是被禁止的。当然多次出现的 <code class=\"language-text\">//</code> 也是不被允许的(为啥捏？因为 <code class=\"language-text\">target</code> 名有可能含有 <code class=\"language-text\">.</code>)</li>\n<li>包名, <code class=\"language-text\">//package-name:...</code></li>\n<li>包含 <code class=\"language-text\">BUILD</code> 文件的目录名就是包名，例如 <code class=\"language-text\">my/app</code>。注意包名中不能含有 <code class=\"language-text\">/</code></li>\n<li>不能含有 <code class=\"language-text\">//</code>，不能以 <code class=\"language-text\">/</code> 结尾</li>\n</ul>\n<h4 id=\"规则\" style=\"position:relative;\"><a href=\"#%E8%A7%84%E5%88%99\" aria-label=\"规则 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>规则</h4>\n<p>给个样例看一下，</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">cc_binary(\n    name = &quot;my_app&quot;,\n    srcs = [&quot;my_app.cc&quot;],\n    deps = [\n        &quot;//absl/base&quot;,\n        &quot;//absl/strings&quot;,\n    ],\n)</code></pre></div>\n<ul>\n<li><code class=\"language-text\">srcs</code> 属性 [ <code class=\"language-text\">labels</code> 的一个列表]</li>\n<li>\n<p><code class=\"language-text\">outs</code> 属性 [ <code class=\"language-text\">output labels</code> 的一个列表]</p>\n<ul>\n<li>不能含有包的部分</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"build-文件\" style=\"position:relative;\"><a href=\"#build-%E6%96%87%E4%BB%B6\" aria-label=\"build 文件 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>BUILD 文件</h4>\n<p><code class=\"language-text\">BUILD</code> 文件使用的命令式语言是 <code class=\"language-text\">Starlark</code> 。虽然说注意顺序是必要的，但是大部分的情形下，<code class=\"language-text\">BUILD</code> 文件仅仅包含<em>构建规则</em> 的声明，并且这些声明的先后顺序是无关紧要的。当一个构建规则函数，例如 <code class=\"language-text\">cc_library</code> 被执行的时候，它在 <em>依赖图</em> 中创建一个新的 <em>目标</em>。这个目标之后可以被通过 <em>标签</em> 引用。所以仅仅更改声明顺序是没有关系的。</p>\n<p><code class=\"language-text\">BUILD</code> 文件中不能包含函数的定义，<code class=\"language-text\">for</code> 语句或者 <code class=\"language-text\">if</code> 语句。但是 <code class=\"language-text\">list comprehensions</code> 和 <code class=\"language-text\">if</code> 表达式是 OK 的。函数在 <code class=\"language-text\">.bzl</code> 文件中声明，另外 <code class=\"language-text\">*args</code> 和 <code class=\"language-text\">**kwargs</code> 不被允许出现在 <code class=\"language-text\">BUILD</code> 文件中，只能显式地全部列出来。</p>\n<p>不能在 <code class=\"language-text\">Starlark</code> 中随意使用 <code class=\"language-text\">IO</code>。</p>\n<p>编码只能使用 <code class=\"language-text\">ASCII</code>。（连 <code class=\"language-text\">utf-8</code> 都不支持的吗！）</p>\n<h4 id=\"加载插件\" style=\"position:relative;\"><a href=\"#%E5%8A%A0%E8%BD%BD%E6%8F%92%E4%BB%B6\" aria-label=\"加载插件 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>加载插件</h4>\n<p>插件是以 <code class=\"language-text\">.bzl</code> 结尾的文件。</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">load(&quot;//foo/bar:file.bzl&quot;, &quot;some_library&quot;)</code></pre></div>\n<p>这段代码将会加载 <code class=\"language-text\">foo/bar/file.bzl</code> 并且把符号 <code class=\"language-text\">some_library</code> 添加到环境中。可以用来加载规则、字符串、函数、常量。注意 <code class=\"language-text\">load</code> 接受可变参数用来添加多个符号；实参必须是<strong>字符串字面量</strong>，不能是变量。不能把 <code class=\"language-text\">load</code> 放到函数里，只能放到顶层。语句中的相对标签应该使用 <code class=\"language-text\">:</code> 作为起始。<code class=\"language-text\">load</code> 也支持别名。把这些规则缝合到一起看一下，</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">load(&quot;:my_rules.bzl&quot;, &quot;some_rule&quot;, nice_alias = &quot;some_other_rule&quot;)</code></pre></div>\n<p>注意 <code class=\"language-text\">.bzl</code> 文件中， 以下划线开头的符号不会被导出、并且不能被其他的导入。目前也不需要使用 <code class=\"language-text\">exports_files</code> 让某个符号可见。</p>\n<h4 id=\"构建规则的类型\" style=\"position:relative;\"><a href=\"#%E6%9E%84%E5%BB%BA%E8%A7%84%E5%88%99%E7%9A%84%E7%B1%BB%E5%9E%8B\" aria-label=\"构建规则的类型 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>构建规则的类型</h4>\n<p>不同语言使用的构建语句成组出现。例如，对于 C++ ，<code class=\"language-text\">cc_binary</code>, <code class=\"language-text\">cc_library</code>, <code class=\"language-text\">cc_test</code> 对应可执行、库、测试。Java 的前缀是 <code class=\"language-text\">java_*</code> 。当然你自己创建一些新的规则也是可以的，</p>\n<ul>\n<li><code class=\"language-text\">*_binary</code> 规则使用给定的语言构造可执行程序。执行构建后，对应名字的可执行文件将会出现在当前规则标签的输出树中。例如 <code class=\"language-text\">//my:program</code> 将会出现在 <code class=\"language-text\">$(BINDIR)/my/program</code></li>\n<li><code class=\"language-text\">*_library</code></li>\n<li><code class=\"language-text\">*_test</code></li>\n</ul>\n<h4 id=\"依赖\" style=\"position:relative;\"><a href=\"#%E4%BE%9D%E8%B5%96\" aria-label=\"依赖 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>依赖</h4>\n<p>依赖图是 <strong>DAG</strong>. 直接依赖、传递依赖</p>\n<h5 id=\"实际和声明的依赖\" style=\"position:relative;\"><a href=\"#%E5%AE%9E%E9%99%85%E5%92%8C%E5%A3%B0%E6%98%8E%E7%9A%84%E4%BE%9D%E8%B5%96\" aria-label=\"实际和声明的依赖 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>实际和声明的依赖</h5>\n<p>目标 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span></span></span></span> 实际依赖目标 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> 当且仅当 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> 存在，并且是最新版本时才可正确构建目标 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span></span></span></span>。</p>\n<p>目标 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span></span></span></span> 声明依赖目标 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> 当且仅当在包 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span></span></span></span> 中有一条从 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> 的依赖边。</p>\n<p>要求所有的实际依赖必须在声明依赖中出现。不过过多的声明依赖让构造速度减慢。</p>\n<p>在构建目标 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span></span></span></span> 的时候，构建工具检查 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span></span></span></span> 依赖的传递闭包，确保这些目标的所有更改都能影响最终的结果，如果需要的话，重新构建中间件。</p>\n<p>考虑这样的一个问题，</p>\n<p>一开始，事情很美好。</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\"># In file a/BUILD\n\nrule(\n    name = &quot;a&quot;,\n    srcs = &quot;a.in&quot;,\n    deps = &quot;//b:b&quot;,\n)</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\"># In file b/BUILD\n\nrule(\n    name = &quot;b&quot;,\n    srcs = &quot;b.in&quot;,\n    deps = &quot;//c:c&quot;,\n)</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// a/a.in</span>\n<span class=\"token keyword\">import</span> b<span class=\"token punctuation\">;</span>\nb<span class=\"token punctuation\">.</span><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// b/b.in</span>\n<span class=\"token keyword\">import</span> c<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    c<span class=\"token punctuation\">.</span><span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>之后我们在 <code class=\"language-text\">a.in</code> 中引入一点东西，</p>\n<div class=\"gatsby-highlight\" data-language=\"diff\"><pre class=\"language-diff\"><code class=\"language-diff\">import b;\n<span class=\"token inserted-sign inserted\"><span class=\"token prefix inserted\">+</span> import c;\n</span>\nb.foo();\n<span class=\"token inserted-sign inserted\"><span class=\"token prefix inserted\">+</span> c.garply();</span></code></pre></div>\n<p>但是这个时候我们没有在 <code class=\"language-text\">a/BUILD</code> 中引入对 <code class=\"language-text\">c</code> 的 <code class=\"language-text\">deps</code>。换句话说，这个时候的 <em>声明引用</em> 是这样的，  </p>\n<p><img src=\"https://docs.bazel.build/versions/master/images/a_b_c.svg\"></p>\n<p>与此同时 <em>实际引用</em> 是这样的，  </p>\n<p><img src=\"https://docs.bazel.build/versions/master/images/a_b_c_ac.svg\"></p>\n<p>这两个图的传递闭包是一样的，所以构造的时候应该没什么问题——但是这个时候，有个人重构了 <code class=\"language-text\">b</code> , <code class=\"language-text\">b</code> 不再依赖 <code class=\"language-text\">c</code> 了：</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\"># In file b/BUILD\nrule(\n    name = &quot;b&quot;,\n    srcs = &quot;b.in&quot;,\n    deps = &quot;//d:d&quot;,\n)</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// b/b.in</span>\n<span class=\"token keyword\">import</span> d<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    d<span class=\"token punctuation\">.</span><span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><em>声明引用</em> 现在变成了这个样子，\n<img src=\"https://docs.bazel.build/versions/master/images/ab_c.svg\">,</p>\n<p><em>实际引用</em> 是这样的，\n<img src=\"https://docs.bazel.build/versions/master/images/a_b_a_c.svg\">,</p>\n<p>你发现 <em>实际引用</em> 中的这条边 <code class=\"language-text\">a --&gt; c</code> 并未在 <em>声明引用</em> 中出现 —— 这就会让构建出现问题。</p>\n<h5 id=\"依赖的类型\" style=\"position:relative;\"><a href=\"#%E4%BE%9D%E8%B5%96%E7%9A%84%E7%B1%BB%E5%9E%8B\" aria-label=\"依赖的类型 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>依赖的类型</h5>\n<p>大部分的构造规则拥有三种的依赖类型：<code class=\"language-text\">srcs</code>, <code class=\"language-text\">deps</code>, <code class=\"language-text\">data</code>。</p>\n<ul>\n<li><code class=\"language-text\">srcs</code> 依赖</li>\n</ul>\n<p>直接被规则使用或者输出源文件的构建规则</p>\n<ul>\n<li><code class=\"language-text\">deps</code> 依赖</li>\n</ul>\n<p>指向被独立构建模块的规则。这些独立构建的模块提供头文件、符号、库……</p>\n<ul>\n<li><code class=\"language-text\">data</code> 依赖</li>\n</ul>\n<p>例如单元测试中使用的数据文件。</p>\n<h5 id=\"使用标签指代目录\" style=\"position:relative;\"><a href=\"#%E4%BD%BF%E7%94%A8%E6%A0%87%E7%AD%BE%E6%8C%87%E4%BB%A3%E7%9B%AE%E5%BD%95\" aria-label=\"使用标签指代目录 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>使用标签指代目录</h5>\n<h3 id=\"命令\" style=\"position:relative;\"><a href=\"#%E5%91%BD%E4%BB%A4\" aria-label=\"命令 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>命令</h3>\n<ul>\n<li><code class=\"language-text\">bazel build path/to/srcs:target</code> </li>\n<li><code class=\"language-text\">bazel run path/to/srcs:target</code></li>\n<li><code class=\"language-text\">bazel test path/to/srcs:target</code></li>\n<li><code class=\"language-text\">bazel clean</code></li>\n</ul>\n<p>如果 <code class=\"language-text\">target</code> 是 <code class=\"language-text\">all</code>，那么就是构建当前目录下的所有东西。例如 <code class=\"language-text\">bazel build src:all</code>; 但是如果要构建 <code class=\"language-text\">workspace</code> 下面的所有目标，可以使用 <code class=\"language-text\">...</code> 这样的模式。</p>\n<h3 id=\"引入其他语言\" style=\"position:relative;\"><a href=\"#%E5%BC%95%E5%85%A5%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80\" aria-label=\"引入其他语言 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>引入其他语言</h3>\n<p><code class=\"language-text\">WORKSPACE</code> 可以 <code class=\"language-text\">load</code> 一些东西……</p>\n<p>自带的先引进来</p>\n<div class=\"gatsby-highlight\" data-language=\"starlark\"><pre class=\"language-starlark\"><code class=\"language-starlark\">load(&quot;@bazel_tools//tools/build_defs/repo:http.bzl&quot;, &quot;http_archive&quot;)\n# 类似的还有 git_repostiory\nload(&quot;@bazel_tools//tools/build_defs/repo:git.bzl&quot;, &quot;git_repository&quot;)</code></pre></div>\n<p>然后你就可以引入外部的规则啦! 引入的东西下载到 <code class=\"language-text\">bazel-&lt;workspace_name&gt;/external/</code> 下面。\n引入一个 <code class=\"language-text\">Golang</code> 的试一下，首先先下载，</p>\n<div class=\"gatsby-highlight\" data-language=\"bazel\"><pre class=\"language-bazel\"><code class=\"language-bazel\">http_archive(\n    name = &quot;io_bazel_rules_go&quot;,\n    urls = [&quot;https://github.com/bazelbuild/rules_go/releases/download/v0.26.0/rules_go-v0.26.0.tar.gz&quot;],\n)</code></pre></div>\n<p>之后这个规则对应的仓库名就叫 <code class=\"language-text\">io_bazel_rules_go</code>，初始化一下，</p>\n<div class=\"gatsby-highlight\" data-language=\"bazel\"><pre class=\"language-bazel\"><code class=\"language-bazel\">load(&quot;@io_bazel_rules_go//go:deps.bzl&quot;, &quot;go_register_toolchains&quot;, &quot;go_rules_dependencies&quot;)\n\ngo_rules_dependencies()\n\ngo_register_toolchains(\n    version = &quot;host&quot;,\n)</code></pre></div>\n<p>好了，现在可以在 <code class=\"language-text\">BUILD</code> 下面写规则了</p>\n<div class=\"gatsby-highlight\" data-language=\"bazel\"><pre class=\"language-bazel\"><code class=\"language-bazel\">load(&quot;@io_bazel_rules_go//go:def.bzl&quot;, &quot;go_binary&quot;)\ngo_binary(\n    name = &quot;hello_world_go&quot;,\n    srcs = [&quot;hello_world.go&quot;],\n)</code></pre></div>\n<p>引入 <code class=\"language-text\">Rust</code>，参考 <a href=\"https://bazelbuild.github.io/rules_rust/\">https://bazelbuild.github.io/rules_rust/</a>  </p>\n<div class=\"gatsby-highlight\" data-language=\"bazel\"><pre class=\"language-bazel\"><code class=\"language-bazel\">http_archive(\n    name = &quot;rules_rust&quot;,\n    sha256 = &quot;e6d835ee673f388aa5b62dc23d82db8fc76497e93fa47d8a4afe97abaf09b10d&quot;,\n    strip_prefix = &quot;rules_rust-f37b9d6a552e9412285e627f30cb124e709f4f7a&quot;,\n    urls = [\n        # Master branch as of 2021-01-27\n        &quot;https://github.com/bazelbuild/rules_rust/archive/f37b9d6a552e9412285e627f30cb124e709f4f7a.tar.gz&quot;,\n    ],\n)\n\nload(&quot;@rules_rust//rust:repositories.bzl&quot;, &quot;rust_repositories&quot;)\n\nrust_repositories()</code></pre></div>\n<p>之后是 <code class=\"language-text\">BUILD</code>，</p>\n<div class=\"gatsby-highlight\" data-language=\"bazel\"><pre class=\"language-bazel\"><code class=\"language-bazel\">rust_binary(\n    name = &quot;hello_world_rust&quot;,\n    srcs = [&quot;hello_world.rs&quot;],\n)</code></pre></div>\n<h3 id=\"引入-protobuf-依赖\" style=\"position:relative;\"><a href=\"#%E5%BC%95%E5%85%A5-protobuf-%E4%BE%9D%E8%B5%96\" aria-label=\"引入 protobuf 依赖 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>引入 Protobuf 依赖</h3>\n<p>以 C++ 为例。首先在 <code class=\"language-text\">WORKSPACE</code> 中引入 <code class=\"language-text\">proto</code> 依赖，</p>\n<div class=\"gatsby-highlight\" data-language=\"bazel\"><pre class=\"language-bazel\"><code class=\"language-bazel\">load(&quot;@bazel_tools//tools/build_defs/repo:git.bzl&quot;, &quot;git_repository&quot;)\n\ngit_repository(\n    name = &quot;rules_proto&quot;,\n    remote = &quot;https://github.com/bazelbuild/rules_proto.git&quot;,\n    commit = &quot;f7a30f6f80006b591fa7c437fe5a951eb10bcbcf&quot;,\n    verbose = True,\n)\n\nload(&quot;@rules_proto//proto:repositories.bzl&quot;, &quot;rules_proto_dependencies&quot;, &quot;rules_proto_toolchains&quot;)\n\nrules_proto_dependencies()\n\nrules_proto_toolchains()</code></pre></div>\n<p>这里不用 <code class=\"language-text\">http_archive</code> 的原因是官方文档给的 <code class=\"language-text\">README</code> 过于久远没有更新，所以和新版的 <code class=\"language-text\">Bazel</code> 有不兼容的地方… </p>\n<p>接着我们在 <code class=\"language-text\">src</code> 下面写一个 <code class=\"language-text\">proto</code>, </p>\n<div class=\"gatsby-highlight\" data-language=\"protobuf\"><pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">syntax</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"proto3\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">package</span> transmission_object<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">message</span> <span class=\"token class-name\">TransmissionObject</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">float</span> value <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">string</span> message <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>保存为 <code class=\"language-text\">transmission_object.proto</code>。接着写 <code class=\"language-text\">BUILD</code> 文件，</p>\n<div class=\"gatsby-highlight\" data-language=\"bazel\"><pre class=\"language-bazel\"><code class=\"language-bazel\">load(&quot;@rules_proto//proto:defs.bzl&quot;, &quot;proto_library&quot;)\n\nproto_library(\n    name = &quot;transmission_object_proto&quot;,\n    srcs = [&quot;transmission_object.proto&quot;],\n)\n\ncc_proto_library(\n    name = &quot;transmission_object_cxx_proto&quot;,\n    deps = [&quot;:transmission_object_proto&quot;],\n)</code></pre></div>\n<p><code class=\"language-text\">bazel</code> 将会根据这个生成 C++ 对应的 <code class=\"language-text\">protobuf</code> 头文件和代码。我们写一个测试程序，</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"src/transmission_object.pb.h\"</span></span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    std<span class=\"token operator\">::</span>ios_base<span class=\"token operator\">::</span><span class=\"token function\">sync_with_stdio</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    GOOGLE_PROTOBUF_VERIFY_VERSION<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">float</span> value<span class=\"token punctuation\">;</span>\n    std<span class=\"token operator\">::</span>string message<span class=\"token punctuation\">;</span>\n    std<span class=\"token operator\">::</span>cin <span class=\"token operator\">>></span> value <span class=\"token operator\">>></span> message<span class=\"token punctuation\">;</span>\n\n    transmission_object<span class=\"token operator\">::</span>TransmissionObject obj<span class=\"token punctuation\">;</span>\n    obj<span class=\"token punctuation\">.</span><span class=\"token function\">set_message</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    obj<span class=\"token punctuation\">.</span><span class=\"token function\">set_value</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> obj<span class=\"token punctuation\">.</span><span class=\"token function\">DebugString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>接着在 <code class=\"language-text\">BUILD</code> 中加入 <code class=\"language-text\">cc_binary</code>，</p>\n<div class=\"gatsby-highlight\" data-language=\"bazel\"><pre class=\"language-bazel\"><code class=\"language-bazel\">cc_binary(\n    name = &quot;proto_cxx_test&quot;,\n    srcs = [\n        &quot;run.cc&quot;,\n    ],\n    deps = [&quot;:transmission_object_cxx_proto&quot;],\n)</code></pre></div>\n<p>就可以愉快地构建啦！ <code class=\"language-text\">bazel run src:proto_cxx_test</code>  </p>\n<p>注意 <code class=\"language-text\">cc</code> 中包含 <code class=\"language-text\">transmission_object.pb.h</code> 的方式。<code class=\"language-text\">bazel</code> 默认将 <code class=\"language-text\">proto</code> 生成在 <code class=\"language-text\">bazel-bin/src/</code> 下面。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># bazel run src:proto_cxx_test</span>\nINFO: Analyzed target //src:proto_cxx_test <span class=\"token punctuation\">(</span><span class=\"token number\">0</span> packages loaded, <span class=\"token number\">0</span> targets configured<span class=\"token punctuation\">)</span>.\nINFO: Found <span class=\"token number\">1</span> target<span class=\"token punctuation\">..</span>.\nTarget //src:proto_cxx_test up-to-date:\n  bazel-bin/src/proto_cxx_test.exe\nINFO: Elapsed time: <span class=\"token number\">0</span>.207s, Critical Path: <span class=\"token number\">0</span>.01s\nINFO: <span class=\"token number\">1</span> process: <span class=\"token number\">1</span> internal.\nINFO: Build completed successfully, <span class=\"token number\">1</span> total action\nINFO: Build completed successfully, <span class=\"token number\">1</span> total action\n<span class=\"token number\">2.7182818</span> Hello,protobuf\nvalue: <span class=\"token number\">2.71828175</span>\nmessage: <span class=\"token string\">\"Hello,protobuf\"</span></code></pre></div>\n<p>想用 GCC 的话可以先查询一下目前有的工具链， </p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">bazel query @local_config_cc//:toolchain --output<span class=\"token operator\">=</span>build</code></pre></div>\n<p><code class=\"language-text\">MinGW-w64</code> 对应的名字是 <code class=\"language-text\">mingw-gcc</code></p>\n<div class=\"gatsby-highlight\" data-language=\"bazel\"><pre class=\"language-bazel\"><code class=\"language-bazel\"># Hardcoded toolchain, legacy behaviour.\ncc_toolchain_suite(\n    name = &quot;toolchain&quot;,\n    toolchains = {\n        &quot;armeabi-v7a|compiler&quot;: &quot;:cc-compiler-armeabi-v7a&quot;,\n        &quot;x64_windows|msvc-cl&quot;: &quot;:cc-compiler-x64_windows&quot;,\n        &quot;x64_x86_windows|msvc-cl&quot;: &quot;:cc-compiler-x64_x86_windows&quot;,\n        &quot;x64_arm_windows|msvc-cl&quot;: &quot;:cc-compiler-x64_arm_windows&quot;,\n        &quot;x64_arm64_windows|msvc-cl&quot;: &quot;:cc-compiler-x64_arm64_windows&quot;,\n        &quot;x64_windows|msys-gcc&quot;: &quot;:cc-compiler-x64_windows_msys&quot;,\n        &quot;x64_windows|mingw-gcc&quot;: &quot;:cc-compiler-x64_windows_mingw&quot;,\n        &quot;x64_windows|clang-cl&quot;: &quot;:cc-compiler-x64_windows-clang-cl&quot;,\n        &quot;x64_windows_msys&quot;: &quot;:cc-compiler-x64_windows_msys&quot;,\n        &quot;x64_windows&quot;: &quot;:cc-compiler-x64_windows&quot;,\n        &quot;x64_x86_windows&quot;: &quot;:cc-compiler-x64_x86_windows&quot;,\n        &quot;x64_arm_windows&quot;: &quot;:cc-compiler-x64_arm_windows&quot;,\n        &quot;x64_arm64_windows&quot;: &quot;:cc-compiler-x64_arm64_windows&quot;,\n        &quot;armeabi-v7a&quot;: &quot;:cc-compiler-armeabi-v7a&quot;,\n    },\n)</code></pre></div>\n<p>运行 <code class=\"language-text\">bazel build src:proto_cxx_test --compiler=&quot;mingw-gcc&quot;</code> 即可。</p>\n<p>当然你也可以在 <code class=\"language-text\">.bazelrc</code> 中强行钦点。</p>","frontmatter":{"title":"Bazel 学习笔记","date":"March 05, 2021"}}},"pageContext":{"slug":"/随手记/bazel-学习笔记/","previous":{"fields":{"slug":"/随手记/新博客/"},"frontmatter":{"title":"新博客","category":"随手记","draft":false}},"next":null}},"staticQueryHashes":["3128451518","52803243"]}